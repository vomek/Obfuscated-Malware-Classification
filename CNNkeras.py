"""
    Keras CNN Code
"""
import tensorflow as tf
from sklearn.preprocessing import Normalizer
from tensorflow.keras import datasets, layers, models
import matplotlib.pyplot as plt
import pickle as pkl
from sklearn.preprocessing import LabelEncoder
#import sys
#sys.stdout = open("test.txt", "w")

from keras import backend as K
from keras.utils import to_categorical
"""
    # loadv data from Pickle file with this function
    # pickleFileName = name of pickle file that needed to load
    # return dataArray=loaded data from pickle file
"""
def loadPickle(pickleFileName): 
    with open(pickleFileName, 'rb') as fileObject:
        dataArray = pkl.load(fileObject)
    fileObject.close()
    return dataArray
def recall_m(y_true, y_pred):
    true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))
    possible_positives = K.sum(K.round(K.clip(y_true, 0, 1)))
    recall = true_positives / (possible_positives + K.epsilon())
    return recall

def precision_m(y_true, y_pred):
    true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))
    predicted_positives = K.sum(K.round(K.clip(y_pred, 0, 1)))
    precision = true_positives / (predicted_positives + K.epsilon())
    return precision

def f1_m(y_true, y_pred):
    precision = precision_m(y_true, y_pred)
    recall = recall_m(y_true, y_pred)
    return 2*((precision*recall)/(precision+recall+K.epsilon()))


'-------------------------------------------------------------------------------------'
# Device configuration
#device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')
#print(device)
'-------------------------------------------------------------------------------------'
# Hyper parameters
num_epochs = 500
num_classes = 25
batch_size = 32
learning_rate = 0.01
n_params=[16,32,64]
'-------------------------------------------------------------------------------------'

"""
    Reading dataset from pickle file
"""
X_train = loadPickle("XTrainPickle.pkl")
y_train = loadPickle("yTrainPickle.pkl")

X_validate = loadPickle("XValidatePickle.pkl")
y_validate = loadPickle("yValidatePickle.pkl")

X_test = loadPickle("XTestPickle.pkl")
y_test = loadPickle("yTestPickle.pkl")


labelencoder = LabelEncoder() 
y_train = labelencoder.fit_transform(y_train) 
labelencoder = LabelEncoder() 
y_validate = labelencoder.fit_transform(y_validate) 
labelencoder = LabelEncoder() 
y_test = labelencoder.fit_transform(y_test) 

"""  
    performing L2 normalization
"""
Data_normalizer = Normalizer(norm='l2').fit(X_train)
X_train = Data_normalizer.transform(X_train)
X_train = X_train.reshape(5324,1024,1)
Data_normalizer = Normalizer(norm='l2').fit(X_validate)
X_validate = Data_normalizer.transform(X_validate)
X_validate = X_validate.reshape(2282,1024,1)
Data_normalizer = Normalizer(norm='l2').fit(X_test)
X_test = Data_normalizer.transform(X_test)
X_test = X_test.reshape(3261,1024, 1)  

y_train = to_categorical(y_train)
y_train = y_train.reshape(5324,9)
y_validate = to_categorical(y_validate)
y_validate = y_validate.reshape(2282,9)
y_test = to_categorical(y_test)
y_test = y_test.reshape(3261,9)

model = models.Sequential()
model.add(layers.Conv1D(64,3,1, input_shape=(1024,1)))
model.add(layers.MaxPooling1D(2))
model.add(layers.Conv1D(128,3,1))
model.add(layers.MaxPooling1D(2))
#model.add(layers.Flatten())
model.add(layers.LSTM(70))
model.add(layers.Dropout(0.1))
#model.summary()

model.add(layers.Flatten())
model.add(layers.Dense(9, activation='softmax'))
#model.add(layers.Dense(25))

model.summary()

model.compile(optimizer='adam',
              loss="categorical_crossentropy",  
              metrics=['accuracy',f1_m,precision_m, recall_m])

history = model.fit(X_train,y_train,epochs=500,
                    validation_data=(X_validate, y_validate))

plt.plot(history.history['accuracy'], label='accuracy')
plt.plot(history.history['val_accuracy'], label = 'val_accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.ylim([1, 9])
plt.legend(loc='lower right')

test_loss, test_acc, f1_score, precision, recall  = model.evaluate(X_test, y_test, verbose=2)
print(test_acc)

#sys.stdout.close()













